import { Platform, Alert } from 'react-native';
import * as InAppPurchases from 'expo-in-app-purchases';
import { SUBSCRIPTION_PLANS } from '@/constants/subscriptions';

// In-App Purchase Status
export interface PurchaseStatus {
  isAvailable: boolean;
  canMakePayments: boolean;
  products: Product[];
}

export interface Product {
  id: string;
  title: string;
  description: string;
  price: string;
  priceAmount: number;
  currency: string;
}

export interface PurchaseResult {
  success: boolean;
  error?: string;
  transactionId?: string;
  productId?: string;
  receiptData?: string;
  originalTransactionId?: string;
  purchaseDate?: string;
  expiresDate?: string;
}

export interface ReceiptValidationResult {
  success: boolean;
  environment?: string;
  subscription?: {
    isValid: boolean;
    productId?: string;
    expiresDate?: string;
    isExpired: boolean;
  };
  error?: string;
}

// Initialize in-app purchases
let isInitialized = false;

/**
 * Initialize in-app purchases
 */
export const initializeInAppPurchases = async (): Promise<void> => {
  if (Platform.OS !== 'ios' || isInitialized) {
    return;
  }

  try {
    await InAppPurchases.connectAsync();
    isInitialized = true;
    console.log('In-app purchases initialized successfully');
  } catch (error) {
    console.error('Failed to initialize in-app purchases:', error);
    throw error;
  }
};

/**
 * Disconnect in-app purchases
 */
export const disconnectInAppPurchases = async (): Promise<void> => {
  if (Platform.OS !== 'ios' || !isInitialized) {
    return;
  }

  try {
    await InAppPurchases.disconnectAsync();
    isInitialized = false;
    console.log('In-app purchases disconnected');
  } catch (error) {
    console.error('Failed to disconnect in-app purchases:', error);
  }
};

/**
 * Check in-app purchase availability
 */
export const checkInAppPurchaseAvailability = async (): Promise<PurchaseStatus> => {
  if (Platform.OS !== 'ios') {
    return {
      isAvailable: false,
      canMakePayments: false,
      products: [],
    };
  }

  try {
    // Initialize if not already done
    if (!isInitialized) {
      await initializeInAppPurchases();
    }

    // Get product IDs from subscription plans
    const productIds = SUBSCRIPTION_PLANS.map(plan => plan.productId);
    
    // Fetch products from App Store
    const { responseCode, results } = await InAppPurchases.getProductsAsync(productIds);
    
    if (responseCode === InAppPurchases.IAPResponseCode.OK && results) {
      const products: Product[] = results.map(product => ({
        id: product.productId,
        title: product.title,
        description: product.description,
        price: product.price,
        priceAmount: parseFloat(product.price.replace(/[^0-9.]/g, '')),
        currency: product.priceCurrencyCode || 'USD',
      }));

      return {
        isAvailable: true,
        canMakePayments: true,
        products,
      };
    } else {
      console.error('Failed to fetch products:', responseCode);
      return {
        isAvailable: false,
        canMakePayments: true,
        products: [],
      };
    }
  } catch (error) {
    console.error('Error checking in-app purchase availability:', error);
    return {
      isAvailable: false,
      canMakePayments: false,
      products: [],
    };
  }
};

/**
 * Purchase a subscription
 */
export const purchaseSubscription = async (productId: string): Promise<PurchaseResult> => {
  if (Platform.OS !== 'ios') {
    return {
      success: false,
      error: 'In-app purchases are only available on iOS',
    };
  }

  try {
    // Initialize if not already done
    if (!isInitialized) {
      await initializeInAppPurchases();
    }

    console.log('Processing in-app purchase for product:', productId);
    
    // Purchase the product
    const result = await InAppPurchases.purchaseItemAsync(productId);
    
    if (result.responseCode === InAppPurchases.IAPResponseCode.OK && result.results && result.results.length > 0) {
      const purchase = result.results[0];
      
      console.log('In-app purchase successful');
      
      // Finish the transaction
      await InAppPurchases.finishTransactionAsync(purchase, true);
      
      // Generate a mock receipt for sandbox testing
      const receiptData = generateMockReceipt(productId, purchase.transactionId);
      
      return {
        success: true,
        transactionId: purchase.transactionId,
        productId: purchase.productId,
        receiptData,
        originalTransactionId: purchase.originalTransactionIdentifier || purchase.transactionId,
        purchaseDate: purchase.purchaseTime ? new Date(purchase.purchaseTime).toISOString() : new Date().toISOString(),
        expiresDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(), // 1 year
      };
    } else {
      console.error('Purchase failed with response code:', result.responseCode);
      return {
        success: false,
        error: `Purchase failed with response code: ${result.responseCode}`,
      };
    }

  } catch (error: any) {
    console.error('In-app purchase error:', error);
    
    return {
      success: false,
      error: error.message || 'Purchase failed',
    };
  }
};

/**
 * Generate mock receipt for sandbox testing
 */
const generateMockReceipt = (productId: string, transactionId: string): string => {
  const receipt = {
    receipt_type: "ProductionSandbox",
    bundle_id: "com.biztomate.scanner",
    application_version: "1.2",
    original_application_version: "1.2",
    in_app: [
      {
        quantity: "1",
        product_id: productId,
        transaction_id: transactionId,
        original_transaction_id: transactionId,
        purchase_date: new Date().toISOString(),
        purchase_date_ms: Date.now().toString(),
        purchase_date_pst: new Date().toLocaleString("en-US", {timeZone: "America/Los_Angeles"}),
        original_purchase_date: new Date().toISOString(),
        original_purchase_date_ms: Date.now().toString(),
        original_purchase_date_pst: new Date().toLocaleString("en-US", {timeZone: "America/Los_Angeles"}),
        expires_date: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(),
        expires_date_ms: (Date.now() + 365 * 24 * 60 * 60 * 1000).toString(),
        expires_date_pst: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toLocaleString("en-US", {timeZone: "America/Los_Angeles"}),
        web_order_line_item_id: Math.floor(Math.random() * 1000000).toString(),
        is_trial_period: "false",
        is_in_intro_offer_period: "false",
        subscription_group_identifier: "21482456"
      }
    ],
    version_external_identifier: "0",
    receipt_creation_date: new Date().toISOString(),
    receipt_creation_date_ms: Date.now().toString(),
    receipt_creation_date_pst: new Date().toLocaleString("en-US", {timeZone: "America/Los_Angeles"}),
    request_date: new Date().toISOString(),
    request_date_ms: Date.now().toString(),
    request_date_pst: new Date().toLocaleString("en-US", {timeZone: "America/Los_Angeles"}),
    original_purchase_date: new Date().toISOString(),
    original_purchase_date_ms: Date.now().toString(),
    original_purchase_date_pst: new Date().toLocaleString("en-US", {timeZone: "America/Los_Angeles"}),
    adam_id: 0,
    download_id: 0,
    app_item_id: 0,
    version_bundle_id: "com.biztomate.scanner"
  };

  // Convert to base64 encoded string (simulating Apple's receipt format)
  return Buffer.from(JSON.stringify(receipt)).toString('base64');
};

/**
 * Restore purchases
 */
export const restorePurchases = async (): Promise<PurchaseResult[]> => {
  if (Platform.OS !== 'ios') {
    return [{
      success: false,
      error: 'In-app purchases are only available on iOS',
    }];
  }

  try {
    // Initialize if not already done
    if (!isInitialized) {
      await initializeInAppPurchases();
    }

    console.log('Restoring purchases...');
    
    // Restore purchases
    const result = await InAppPurchases.getPurchaseHistoryAsync();
    
    if (result.responseCode === InAppPurchases.IAPResponseCode.OK && result.results) {
      const restoredPurchases: PurchaseResult[] = [];
      
      for (const purchase of result.results) {
        // Generate mock receipt for restored purchase
        const receiptData = generateMockReceipt(purchase.productId, purchase.transactionId);
        
        restoredPurchases.push({
          success: true,
          transactionId: purchase.transactionId,
          productId: purchase.productId,
          receiptData,
          originalTransactionId: purchase.originalTransactionIdentifier || purchase.transactionId,
          purchaseDate: purchase.purchaseTime ? new Date(purchase.purchaseTime).toISOString() : new Date().toISOString(),
          expiresDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(), // 1 year
        });
      }

      console.log('Restored purchases:', restoredPurchases.length);
      return restoredPurchases;
    } else {
      console.error('Restore failed with response code:', result.responseCode);
      return [{
        success: false,
        error: `Restore failed with response code: ${result.responseCode}`,
      }];
    }

  } catch (error: any) {
    console.error('Restore purchases error:', error);
    
    return [{
      success: false,
      error: error.message || 'Restore failed',
    }];
  }
};

/**
 * Validate receipt on server
 */
export const validateReceipt = async (receiptData: string): Promise<ReceiptValidationResult> => {
  try {
    console.log('Validating receipt on server...');
    
    // In a real implementation, you would send the receipt to your server
    // for validation against Apple's servers
    const response = await fetch('/api/receipt-validation', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        receiptData,
        password: process.env.APP_STORE_SHARED_SECRET, // Your app-specific shared secret
      }),
    });

    const result = await response.json();
    
    if (!response.ok) {
      return {
        success: false,
        error: result.error || 'Receipt validation failed',
      };
    }

    return {
      success: true,
      environment: result.environment,
      subscription: result.subscription,
    };
    
  } catch (error) {
    console.error('Receipt validation error:', error);
    
    // For development/testing, simulate successful validation
    // In production, this should always validate with Apple's servers
    const isDevelopment = __DEV__;
    
    if (isDevelopment) {
      console.log('Development mode: Simulating successful receipt validation');
      return {
        success: true,
        environment: 'Sandbox',
        subscription: {
          isValid: true,
          productId: 'com.biztomate.scanner.basic',
          expiresDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(),
          isExpired: false,
        },
      };
    }
    
    return {
      success: false,
      error: 'Failed to validate receipt',
    };
  }
};

/**
 * Show purchase error alert
 */
export const showPurchaseErrorAlert = (error: string) => {
  Alert.alert(
    'Purchase Failed',
    error || 'Your purchase could not be completed. Please try again.',
    [{ text: 'OK' }]
  );
};

/**
 * Show restore success alert
 */
export const showRestoreSuccessAlert = (restoredCount: number) => {
  if (restoredCount > 0) {
    Alert.alert(
      'Purchases Restored',
      `Successfully restored ${restoredCount} purchase${restoredCount > 1 ? 's' : ''}.`,
      [{ text: 'OK' }]
    );
  } else {
    Alert.alert(
      'No Purchases Found',
      'No previous purchases were found to restore.',
      [{ text: 'OK' }]
    );
  }
}; 